/*!
 * \file
 * \author Nikos Tsakiridis <tsakirin@auth.gr>
 * \version 1.0
 *
 * \brief Definitions for CEC function problems
 */

#ifndef DE_CEC_BASIC_PROBLEM_HPP
#define DE_CEC_BASIC_PROBLEM_HPP

#include <vector>
#include <map>
#include <assert.h>
#include <cstdio>
#include <stdexcept>
#include "problem/simple_problem.hpp"

namespace DE {
namespace Problem {

/*! \class CECFunction
 *  \brief A wrapper of Base for fitness functions based on CEC-2015
 *
 *  Basic CEC functions should inherit this class and implement
 *  the evaluate function. The fitness function in this class first
 *  shifts, then scales, then rotates the data if these transformations
 *  are specified.
 */

template <class T>
class CECFunction : public SimpleFitnessFunction<T> {
 public:
  CECFunction(const std::size_t D, const char* name)
      : SimpleFitnessFunction<T>(D, name) {
    for (std::size_t i = 0; i < Base<T>::D_; ++i)
      SimpleFitnessFunction<T>::constrains_.insert(
          std::make_pair(i, Constrain<double>(-100, 100)));
  };

  double fitness(const std::vector<T>& chromosome) const {
    assert(chromosome.size() == Base<T>::D_);
    if (shift_.empty() && rotation_.empty() && scale_ == 1.0)
      return evaluate(chromosome);
    if (handle_shift_and_rotation_internally_)
      return evaluate(chromosome);
    std::vector<T> transformed = chromosome;
    if (!shift_.empty())
      transformed = shift(chromosome);
    if (scale_ != 1.0)
      for (auto& gene : transformed)
        gene *= scale_;
    if (!rotation_.empty())
      transformed = rotate(transformed);
    return evaluate(transformed);
  };

  /*!
   * \brief Evaluate the function on the chromosome
   *
   * \param chromosome : The vector on which to evaluate the function
   *
   * \return The mathematical function's result for this vector
   */

  virtual double evaluate(const std::vector<T>& chromosome) const = 0;

  /*!
   * \brief Parse the shift file (shift_data_*.txt) generated by the .m file
   *
   * \param shift_file    : Path to the .txt file
   * \param skip_rows     : If specified, skip this many rows
   *
   * \throw std::runtime_error if the file cannot be opened
   */

  void parse_shift_file(const char* shift_file,
                        const std::size_t skip_rows = 0) {
    shift_.resize(Base<T>::D_);
    FILE* fpt = fopen(shift_file, "r");
    if (fpt == NULL)
      throw std::runtime_error("Unable to open shift file");
    if (skip_rows > 0)
      forward_file_pointer(fpt, skip_rows);
    for (std::size_t i = 0; i < Base<T>::D_; ++i)
      fscanf(fpt, "%lf", &shift_[i]);
    fclose(fpt);
  }

  /*!
   * \brief Parse the rotation file (M_*.txt) generated by the .m file
   *
   * \param rotation_file : Path to the .txt file
   * \param skip_rows     : If specified, skip this many rows
   *
   * \throw std::runtime_error if the file cannot be opened
   */

  void parse_rotation_file(const char* rotation_file,
                           const std::size_t skip_rows = 0) {
    rotation_.resize(Base<T>::D_);
    for (auto& row : rotation_)
      row.resize(Base<T>::D_);
    FILE* fpt = fopen(rotation_file, "r");
    if (fpt == NULL)
      throw std::runtime_error("Unable to open rotation file");
    if (skip_rows > 0)
      forward_file_pointer(fpt, skip_rows);
    for (std::size_t i = 0; i < Base<T>::D_; ++i)
      for (std::size_t j = 0; j < Base<T>::D_; ++j)
        fscanf(fpt, "%lf", &rotation_[i][j]);
    fclose(fpt);
  }

  /*!
   * \brief Set the scale factor of the fitness function
   *
   * \param scale : The new scale value
   */

  void set_scale_factor(const T scale) { scale_ = scale; }

  /*!
   * \brief Get the shifting data
   *
   * \return The shifting data
   */

  auto get_shift_data() const { return shift_; }

 protected:
  T scale_ = 1.0; /*!< If supplied, scale the difference for each gene */
  /*! Vector of size D_ for the shifting of each gene */
  std::vector<T> shift_;
  /*! Vector of size D_, D_ for the rotation of each gene */
  std::vector<std::vector<T>> rotation_;
  bool handle_shift_and_rotation_internally_ = false;
  /*!< If this is set, shift and rotation will not occur prior to calling
   * evaluate */

  /*!
   * \brief Shift each gene by a pre-determined value
   *
   * \param initial : The chromosome to be shifted
   *
   * \return The shifted chromosome
   */

  std::vector<T> shift(const std::vector<T>& initial) const {
    assert(initial.size() == Base<T>::D_);
    assert(shift_.size() == Base<T>::D_);
    std::vector<T> shifted(Base<T>::D_, 0);
    for (std::size_t i = 0; i < Base<T>::D_; ++i)
      shifted[i] = initial[i] - shift_[i];
    return shifted;
  }

  /*!
   * \brief Rotate a given chromosome based on matrix
   *
   * \param initial : The chromosome to be rotated
   *
   * \return The rotated chromosome
   */

  std::vector<T> rotate(const std::vector<T>& initial) const {
    assert(initial.size() == Base<T>::D_);
    assert(rotation_.size() == Base<T>::D_);
    std::vector<T> rotated(Base<T>::D_, 0);
    for (std::size_t i = 0; i < Base<T>::D_; ++i)
      for (std::size_t j = 0; j < Base<T>::D_; ++j)
        rotated[i] += initial[j] * rotation_[i][j];
    return rotated;
  }

  /*!
   * \brief Forward a file pointer by skipping lines
   *
   * Lines are determined by the newline character
   *
   * \param fpt  : The file pointer to be forwarded
   * \param skip : Number of lines to be skipped
   */

  void forward_file_pointer(FILE* fpt, const std::size_t skip) {
    assert(fpt != nullptr);
    char tmp_char;
    for (std::size_t i = 0; i < skip; ++i) {
      fscanf(fpt, "%c", &tmp_char);
      while (tmp_char != '\n') {
        fscanf(fpt, "%c", &tmp_char);
      }
    }
  }
};
}  // namespace Problem
}  // namespace DE
#endif  // DE_CEC_BASIC_PROBLEM_HPP
